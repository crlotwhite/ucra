/*
 * UCRA -> OpenUtau Resampler Manifest Generator
 * Reads a UCRA resampler.json and emits an OpenUtau-style YAML manifest.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "cJSON.h"

typedef struct Args {
    const char* input;
    const char* output;
    const char* executable;
} Args;

static void print_help(const char* prog) {
    printf("UCRA OpenUtau Manifest Generator\n");
    printf("Usage: %s --input resampler.json --output resampler.yaml [--exe resampler]\n", prog);
    printf("\nOptions:\n");
    printf("  --input, -i   Path to UCRA resampler.json\n");
    printf("  --output, -o  Path to output YAML file\n");
    printf("  --exe, -e     Resampler executable name/path (default: resampler)\n");
    printf("  --help, -h    Show this help\n");
}

static int parse_args(int argc, char** argv, Args* out) {
    memset(out, 0, sizeof(*out));
    out->executable = "resampler";
    for (int i = 1; i < argc; ++i) {
        if (!strcmp(argv[i], "--help") || !strcmp(argv[i], "-h")) {
            print_help(argv[0]);
            return 1; // signal help
        } else if ((!strcmp(argv[i], "--input") || !strcmp(argv[i], "-i")) && i + 1 < argc) {
            out->input = argv[++i];
        } else if ((!strcmp(argv[i], "--output") || !strcmp(argv[i], "-o")) && i + 1 < argc) {
            out->output = argv[++i];
        } else if ((!strcmp(argv[i], "--exe") || !strcmp(argv[i], "-e")) && i + 1 < argc) {
            out->executable = argv[++i];
        } else {
            fprintf(stderr, "Unknown or incomplete option: %s\n", argv[i]);
            return -1;
        }
    }
    if (!out->input || !out->output) {
        fprintf(stderr, "Missing required --input and/or --output. Use --help.\n");
        return -1;
    }
    return 0;
}

static char* read_all(const char* path, long* out_len) {
    FILE* f = fopen(path, "rb");
    if (!f) return NULL;
    if (fseek(f, 0, SEEK_END) != 0) { fclose(f); return NULL; }
    long len = ftell(f);
    if (len < 0) { fclose(f); return NULL; }
    rewind(f);
    char* buf = (char*)malloc((size_t)len + 1);
    if (!buf) { fclose(f); return NULL; }
    size_t n = fread(buf, 1, (size_t)len, f);
    fclose(f);
    buf[n] = '\0';
    if (out_len) *out_len = (long)n;
    return buf;
}

static void yaml_escape(const char* in, FILE* out) {
    // Emit a double-quoted YAML string with minimal escaping
    fputc('"', out);
    for (const char* p = in; p && *p; ++p) {
        unsigned char c = (unsigned char)*p;
        if (c == '"' || c == '\\') {
            fputc('\\', out);
            fputc(c, out);
        } else if ((c >= 0 && c < 0x20) || c == 0x7F) {
            fprintf(out, "\\x%02X", c);
        } else {
            fputc(c, out);
        }
    }
    fputc('"', out);
}

static void title_case_from_key(const char* key, char* buf, size_t buflen) {
    // Convert snake_case or lowerCamel to Title Case words
    size_t bi = 0;
    int new_word = 1;
    for (size_t i = 0; key && key[i] && bi + 1 < buflen; ++i) {
        char c = key[i];
        if (c == '_' || c == '-') { new_word = 1; if (bi && buf[bi-1] != ' ') buf[bi++] = ' '; continue; }
        if (new_word) { buf[bi++] = (char)toupper((unsigned char)c); new_word = 0; }
        else { buf[bi++] = c; }
        // Insert space before an uppercase in camelCase
        if (key[i+1] && isupper((unsigned char)key[i+1]) && !new_word) { buf[bi++] = ' '; new_word = 1; }
        if (bi + 2 >= buflen) break;
    }
    buf[bi] = '\0';
}

int main(int argc, char** argv) {
    Args args;
    int par = parse_args(argc, argv, &args);
    if (par != 0) return (par > 0) ? 0 : 2;

    long in_len = 0;
    char* json = read_all(args.input, &in_len);
    if (!json) {
        fprintf(stderr, "Failed to read input: %s\n", args.input);
        return 3;
    }

    cJSON* root = cJSON_Parse(json);
    free(json);
    if (!root) {
        fprintf(stderr, "Invalid JSON in %s\n", args.input);
        return 4;
    }

    const cJSON* name = cJSON_GetObjectItemCaseSensitive(root, "name");
    const cJSON* version = cJSON_GetObjectItemCaseSensitive(root, "version");
    const cJSON* vendor = cJSON_GetObjectItemCaseSensitive(root, "vendor");
    const cJSON* flags = cJSON_GetObjectItemCaseSensitive(root, "flags");

    FILE* out = fopen(args.output, "wb");
    if (!out) {
        fprintf(stderr, "Failed to open output: %s\n", args.output);
        cJSON_Delete(root);
        return 5;
    }

    // Header
    fprintf(out, "# Auto-generated by UCRA ucra_manifest_gen\n");
    fprintf(out, "resampler:\n");
    fprintf(out, "  name: "); yaml_escape(cJSON_IsString(name) ? name->valuestring : "UCRA Engine", out); fprintf(out, "\n");
    fprintf(out, "  executable: "); yaml_escape(args.executable, out); fprintf(out, "\n");
    if (cJSON_IsString(version)) {
        fprintf(out, "  version: "); yaml_escape(version->valuestring, out); fprintf(out, "\n");
    }
    if (cJSON_IsString(vendor)) {
        fprintf(out, "  vendor: "); yaml_escape(vendor->valuestring, out); fprintf(out, "\n");
    }
    fprintf(out, "\nexpressions:\n");

    if (cJSON_IsArray(flags)) {
        const cJSON* it = NULL;
        cJSON_ArrayForEach(it, flags) {
            const cJSON* key = cJSON_GetObjectItemCaseSensitive(it, "key");
            const cJSON* type = cJSON_GetObjectItemCaseSensitive(it, "type");
            const cJSON* desc = cJSON_GetObjectItemCaseSensitive(it, "desc");
            const cJSON* range = cJSON_GetObjectItemCaseSensitive(it, "range");
            const cJSON* values = cJSON_GetObjectItemCaseSensitive(it, "values");
            const cJSON* def = cJSON_GetObjectItemCaseSensitive(it, "default");

            if (!cJSON_IsString(key) || !cJSON_IsString(type)) continue;
            const char* k = key->valuestring;
            char title[256];
            title_case_from_key(k, title, sizeof(title));

            fprintf(out, "  %s:\n", k);
            fprintf(out, "    name: "); yaml_escape(title[0] ? title : k, out); fprintf(out, "\n");
            fprintf(out, "    abbr: %s\n", k);
            if (cJSON_IsString(desc)) {
                fprintf(out, "    note: "); yaml_escape(desc->valuestring, out); fprintf(out, "\n");
            }

            if (!strcmp(type->valuestring, "float") || !strcmp(type->valuestring, "int")) {
                fprintf(out, "    type: Numerical\n");
                double minv = 0.0, maxv = 100.0, defv = 0.0;
                if (cJSON_IsArray(range) && cJSON_GetArraySize(range) >= 2) {
                    const cJSON* r0 = cJSON_GetArrayItem(range, 0);
                    const cJSON* r1 = cJSON_GetArrayItem(range, 1);
                    if (cJSON_IsNumber(r0)) minv = r0->valuedouble;
                    if (cJSON_IsNumber(r1)) maxv = r1->valuedouble;
                }
                if (cJSON_IsNumber(def)) defv = def->valuedouble;
                // Emit as integer when possible
                if (!strcmp(type->valuestring, "int")) {
                    fprintf(out, "    min: %d\n", (int)minv);
                    fprintf(out, "    max: %d\n", (int)maxv);
                    fprintf(out, "    default_value: %d\n", (int)defv);
                } else {
                    fprintf(out, "    min: %.6g\n", minv);
                    fprintf(out, "    max: %.6g\n", maxv);
                    fprintf(out, "    default_value: %.6g\n", defv);
                }
                fprintf(out, "    is_flag: true\n");
                fprintf(out, "    flag: %s\n", k);
            } else if (!strcmp(type->valuestring, "bool")) {
                // Represent as options: '' (off) and 'key' (on)
                int defb = (cJSON_IsBool(def) ? cJSON_IsTrue(def) : (cJSON_IsNumber(def) ? (def->valueint != 0) : 0));
                fprintf(out, "    type: Options\n");
                fprintf(out, "    min: 0\n");
                fprintf(out, "    max: 1\n");
                fprintf(out, "    default_value: %d\n", defb);
                fprintf(out, "    is_flag: true\n");
                fprintf(out, "    options:\n");
                fprintf(out, "    - ''\n");
                fprintf(out, "    - %s\n", k);
            } else if (!strcmp(type->valuestring, "enum")) {
                fprintf(out, "    type: Options\n");
                fprintf(out, "    min: 0\n");
                fprintf(out, "    max: 1\n");
                fprintf(out, "    default_value: 0\n");
                fprintf(out, "    is_flag: true\n");
                fprintf(out, "    options:\n");
                fprintf(out, "    - ''\n");
                if (cJSON_IsArray(values)) {
                    const cJSON* v = NULL;
                    cJSON_ArrayForEach(v, values) {
                        if (cJSON_IsString(v)) {
                            fprintf(out, "    - %s=%s\n", k, v->valuestring);
                        }
                    }
                }
            } else {
                // Fallback: treat unknown types as string options without default
                fprintf(out, "    type: Options\n");
                fprintf(out, "    is_flag: true\n");
                fprintf(out, "    options:\n");
                fprintf(out, "    - ''\n");
            }
        }
    }

    fclose(out);
    cJSON_Delete(root);
    return 0;
}
